---
title: "Analysis for reward vs no reward pollen choice experiments"
output: html_notebook
editor_options: 
  chunk_output_type: console
---



```{r, setup}
ipak <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if(length(new.pkg)) install.packages(new.pkg, dependencies = TRUE)
  sapply(pkg, require, character.only = TRUE)
}
  
packages <- c("ggplot2", "car", "plyr", "tidyr")
ipak(packages)



# dataDir = "D:/Dropbox/UW/ExperWinter2018/BeeTwoFlowerChoiceData/"
# figDir = "D:/Dropbox/UW/ExperWinter2018/BeeTwoFLowerChoiceFigures/"

dataDir = "/Users/cswitzer/Dropbox/UW/ExperWinter2018/BeeTwoFlowerChoiceData"
figDir= "/Users/cswitzer/Dropbox/UW/ExperWinter2018/BeeTwoFlowerChoiceFigures"



```



```{r}
# load in data
csvList = list.files(dataDir)


for (ii in csvList){
 
  
   tmp = read.csv(file.path(dataDir, ii), stringsAsFactors = FALSE)
  
   tmp$ID = ii
   
   if(ii == csvList[1]) newDF = tmp
   else newDF = rbind(tmp, newDF)
}  

```


```{r}
newDF$rewardStatus = tolower(newDF$rewardStatus)

unique(newDF$rewardStatus)


summaryDF = as.data.frame(xtabs(~newDF$ID + newDF$rewardStatus + newDF$accNum))

summaryDF

# convert to wide format


summary_wide = spread(summaryDF,   newDF.accNum, Freq)
summary_wide2 = spread(summaryDF,   newDF.rewardStatus, Freq)

# insert treatment
summary_wide$treatment = sapply(summary_wide$newDF.ID, FUN = function(x) newDF[newDF$ID == x, "treatment"][1])


summary_wide

# remove rows where both rewarded the bee
summary_wide = summary_wide[summary_wide$treatment != "Dev2/ai0_True__Dev2/ai1_True", ]
summary_wide

# make sure at one column is 0
summary_wide$`Dev2/ai0` ==0 | summary_wide$`Dev2/ai1` == 0

# combine to make a visit column
summary_wide$visits = summary_wide$`Dev2/ai0` + summary_wide$`Dev2/ai1`

# make wide
sw3 = spread(summary_wide[, c("newDF.ID", "newDF.rewardStatus", "visits", "treatment")],   newDF.rewardStatus, visits)
sw3

# refref: add hive humber
sw3$colonyNum = sapply(sw3$newDF.ID, FUN = function(x) newDF[newDF$ID == x, "colonyNum"][1])
sw3$IT = sapply(sw3$newDF.ID, FUN = function(x) newDF[newDF$ID == x, "ITSpan_mm"][1])


# now we're ready for binomial regression
sw3$prop = sw3$true / (sw3$true + sw3$false)
write.csv(sw3, file = file.path(figDir, "prelimData.csv"))



ggplot(sw3, aes(x = newDF.ID, y = prop)) + 
  geom_bar(stat = "identity") + 
  geom_hline(aes(yintercept = 0.5), lty = 2) + 
  theme_classic()
  
```


## GLM

```{r}
library(lme4)
sw4 <- sw3


m1 <- glmer(cbind(true, false)~ (1|`newDF.ID`), family = binomial("logit"), data = sw4)
summary(m1)


# evaluate fit
library("blmeco") 
dispersion_glmer(m1) #if the scale paramter is between 0.75 and 1.4, there may not be an overdispersion problem.

qqnorm(ranef(m1)$`newDF.ID`[,1])
qqline(ranef(m1)$`newDF.ID`[,1])

plot(fitted(m1), resid(m1)) #residuals vs fitted
abline(h=0)

# bad at predicting low and high
sw4$fitted <- predict(m1, type = "response") #fitted vs observed
plot(sw4$fitted, sw4$prop)
abline(0,1)


pframe <- data.frame(`newDF.ID` = 99999)
pframe$prob <- 0
pp <- predict(m1, newdata = pframe, re.form=NA, type = 'response') # re.form sets all random effects to 0

bm = bootMer(m1, FUN=function(x){
                        predict(x, 
                                pframe, 
                                re.form=NA, 
                                type = 'response')
                        }, 
             nsim = 1000)

bb2_se <-apply(bm$t,2,function(x) quantile(x, probs = c(0.025, 0.975)))
pframe$blo<-bb2_se[1,]
pframe$bhi<-bb2_se[2,]
pframe$predMean <- pp
pframe <- pframe[, c("blo", "bhi", "predMean")]
pframe


ggplot(pframe, aes(x = 1, y = predMean)) + 
  geom_point() + 
  geom_errorbar(aes(ymin = blo, ymax = bhi), width = 0.1)  + 
  theme_classic() + 
  xlim(0.5,1.5) + 
  xlab("") + 
  ylab("predicted proportion of visits to rewarding flower") + 
  ylim(0,1) + 
  geom_hline(aes(yintercept = 0.5), lty = 2, col = 'red') + 
  theme(axis.ticks.x = element_blank(), 
        axis.text.x = element_blank(), 
        axis.line.x = element_blank())

ggsave(file.path(figDir, "propSuccessPollen_1Mar.pdf"), width = 2, height = 4)

colSums(sw3[, 3:4])[2] / sum(colSums(sw3[, 3:4]))


# diagnostics
plot(m1)

plot(ranef(m1))

```


```{r}
# plot rolling mean
index = numeric()
for(ii in 1:nrow(newDF)){
  if(ii == 1) tmpID_old = "9999999"
  tmpID_new = newDF$ID[ii]
  if(tmpID_new != tmpID_old){
    ctr = 1
  }
  else ctr = ctr + 1
  index[ii] = ctr
  tmpID_old = tmpID_new
}

newDF$index = index



binomial_smooth <- function(...) {
  geom_smooth(method = "glm", method.args = list(family = "binomial"), se = FALSE, ...)
}

newDF2 <- newDF[newDF$index <= 100, ]


newDF2$propIndex = newDF2$index 
for(ii in 1:nrow(newDF2)){
  newDF2$propIndex[ii] = newDF2$index[ii] / sum(newDF2$ID == newDF2$ID[ii])
}

newDF2$propIndex

newDF2$logicalReward = as.numeric(newDF2$rewardStatus == "true")

library(magrittr)

newDF2 %>% head

ggplot(newDF2, aes(x = propIndex, y = logicalReward)) + 
  geom_point(position = position_jitter(height = 0.1), size = 0.5) +
  binomial_smooth()+  
  geom_line(alpha = 0.2) + 
  facet_wrap(~ID) + 
  theme_classic() + 
  xlab("Buzz number")+
  ylab("Reward (1: True, 0: False)")+
  theme(
  strip.background = element_blank(),
  strip.text.x = element_blank(), 
  axis.text.x = element_blank(), 
  panel.border = element_rect(colour = "black", fill=NA, size=0.7)
)
ggsave(file.path(figDir, "BeeChangeOverTime.pdf"), width = 10, height = 6)

ggplot(newDF2[, ], aes(x = index, y = logicalReward)) + 
  geom_point(position = position_jitter(height = 0.1), size = 0.5) +
  binomial_smooth()+  
  geom_line(alpha = 0.2) + 
  facet_wrap(~ID) + 
  theme_classic() + 
  xlab("Buzz number")+
  ylab("Reward (1: True, 0: False)")+
  theme(
  strip.background = element_blank(),
  strip.text.x = element_blank(), 
  axis.text.x = element_blank(), 
  panel.border = element_rect(colour = "black", fill=NA, size=0.7)
)

ggsave(file.path(figDir, "BeeChangeOverTime_notScaled.pdf"), width = 10, height = 6)
```



```{r}
# visit time

newDF2 %>% head

# convert visit time to a timestamp

ttms = newDF2$timestamp %>% as.POSIXct(format="%Y_%m_%d__%H_%M_%OS")


# calculate time differences, based on timestamps
id = newDF2$ID[200]

timeDiffF = function(id){
  tmp = newDF2[newDF2$ID == id, ]
  
  tmsReformat = paste(substr(tmp$timestamp, 1, 20), substr(tmp$timestamp, 22, 999), sep = ".")
  
  ttms = tmsReformat %>% as.POSIXct(format="%Y_%m_%d__%H_%M_%OS")
  
  diffTms = as.numeric(ttms)
  
  for(jj in 1:nrow(tmp)){
    diffTms[jj] <- as.numeric(difftime(ttms[jj], ttms[1], units = "min"))
  }
  
  return(diffTms)
  
}
options(digits.mins = 3)

timeDiffs = sapply(unique(newDF2$ID), FUN = function(x) timeDiffF(x))
dd1  = as.data.frame(unlist(timeDiffs))
dd1$ID = paste0(sapply(rownames(dd1), function(x) strsplit(x, ".csv")[[1]][1]), ".csv")
dd1$index = sapply(rownames(dd1), function(x) strsplit(x, ".csv")[[1]][2]) %>% as.numeric

colnames(dd1)[1] = "TimeSinceStart"
dd1 %>% head


#merge
newDF2 %>% head

ndf3 <- merge(newDF2, dd1)

ndf3 %>% head



# plot

ggplot(ndf3[, ], aes(x = TimeSinceStart, y = logicalReward)) + 
  geom_point(position = position_jitter(height = 0.1), size = 0.5) +
  binomial_smooth(color = 'red')+  
  geom_line(alpha = 0.2) + 
  facet_wrap(~ID) + 
  theme_classic() + 
  xlab("Time since first buzz (min)")+
  ylab("Reward (1: True, 0: False)")+
  theme(
  strip.background = element_blank(),
  strip.text.x = element_blank(), 
  #axis.text.x = element_blank(), 
  panel.border = element_rect(colour = "black", fill=NA, size=0.7)
)

ggsave(file.path(figDir, "BeeChangeOverTime_min.pdf"), width = 10, height = 6)

```


```{r}

m1 = glmer(logicalReward ~ index + (1|ID), family = binomial("logit"), data = newDF2)
summary(m1)

preds = predict(m1, newdata = data.frame(index = 1:100, ID = "9999"), type = 'response', re.form = NA, se = TRUE)

pdframe = data.frame(preds)
pdframe$visitNum = 1:100

ggplot(pdframe, aes(x = visitNum , y = fit)) + 
  geom_ribbon(aes(ymin = fit - 2*se.fit, ymax = fit + 2*se.fit), alpha = 0.3) + 
  geom_line() + 
  theme_classic() + 
  labs(x = "Visit number", y= 'Predicted probability of\nvisiting rewarding flower')
ggsave(file.path(figDir, "BeeChangeOverallPreds.pdf"), width = 5, height = 3.5)


```

# markov chain

```{r}
x <- newDF2$logicalReward
xChar<-as.character(x)

library(markovchain)
mcX<-markovchainFit(xChar)$estimate
mcX
plot(mcX)


sequenceMatr <- createSequenceMatrix(x, sanitize = FALSE)
mcFitMLE <- markovchainFit(data = x)
mcFitBSP <- markovchainFit(data = x, method = "bootstrap", nboot = 5, name = "Bootstrap Mc")


# make list
myList<-list()
for (i in 1:length(unique(newDF2$ID))) {
  myList[[i]]<-as.character(newDF2$logicalReward[newDF2$ID == unique(newDF2$ID)[i]])
}

singleMcFromList<-markovchainFit(data=myList,name="listFit") #fit the MC
singleMcFromList

set.seed(123)
pdf(file.path(figDir, "BeeMarkovChain.pdf"), width = 8, height = 6)
plot(singleMcFromList$estimate)
dev.off()

```
